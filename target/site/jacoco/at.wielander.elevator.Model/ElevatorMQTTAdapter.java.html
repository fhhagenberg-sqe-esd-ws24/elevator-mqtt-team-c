<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ElevatorMQTTAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MQTT Elevator Team C</a> &gt; <a href="index.source.html" class="el_package">at.wielander.elevator.Model</a> &gt; <span class="el_source">ElevatorMQTTAdapter.java</span></div><h1>ElevatorMQTTAdapter.java</h1><pre class="source lang-java linenums">package at.wielander.elevator.Model;

import com.hivemq.client.internal.mqtt.message.MqttMessage;
import com.hivemq.client.mqtt.MqttClient;
import com.hivemq.client.mqtt.MqttClientState;
import com.hivemq.client.mqtt.datatypes.MqttQos;
import com.hivemq.client.mqtt.mqtt3.Mqtt3AsyncClient;
import com.hivemq.client.mqtt.mqtt3.message.Mqtt3Message;
import com.hivemq.client.mqtt.mqtt3.message.connect.connack.Mqtt3ConnAck;
import com.hivemq.client.mqtt.mqtt3.message.publish.Mqtt3Publish;
import com.hivemq.client.mqtt.mqtt3.message.subscribe.Mqtt3Subscribe;
import com.hivemq.client.mqtt.mqtt5.Mqtt5AsyncClient;
import com.hivemq.client.mqtt.mqtt5.Mqtt5Client;
import com.hivemq.client.mqtt.mqtt5.message.publish.Mqtt5Publish;

import java.nio.charset.StandardCharsets;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ElevatorMQTTAdapter {
    private static final String topicBase = &quot;building/&quot;;
    public static final String infoTopic = topicBase + &quot;info/&quot;;
    private static final String statusTopic = topicBase + &quot;status/&quot;;
    private static final String controlTopic = topicBase + &quot;control/&quot;;
    public static final String infoElevatorTopic = infoTopic + &quot;elevator/&quot;;
    public static final String statusElevatorTopic = statusTopic + &quot;elevator/&quot;;
    public static final String controlElevatorTopic = controlTopic + &quot;elevator/&quot;;
    public static final String statusFloorTopic = statusTopic + &quot;floor/&quot;;
    private static final int TIMEOUT_DURATION = 10;
    private Mqtt5AsyncClient client;
    private ElevatorSystem elevatorSystem;
    private final ScheduledExecutorService scheduler;
    private int pollingInterval;

    /**
     * Establishes connection between the MQTT Broker and the Elevator Data Model
     *
     * @param elevatorSystem Data Model for Elevator system
     * @param brokerUrl      URL for MQTT Broker
     * @param clientId       Client ID for MQTT Broker
     */
<span class="fc" id="L44">    public ElevatorMQTTAdapter(ElevatorSystem elevatorSystem, String brokerUrl, String clientId, int pollingInterval) {</span>
<span class="fc" id="L45">        this.elevatorSystem = elevatorSystem;</span>
<span class="fc" id="L46">        this.pollingInterval = pollingInterval;</span>

<span class="fc" id="L48">        String[] urlParts = brokerUrl.replace(&quot;tcp://&quot;, &quot;&quot;).split(&quot;:&quot;);</span>
<span class="fc" id="L49">        String host = urlParts[0];</span>
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">        int port = urlParts.length &gt; 1 ? Integer.parseInt(urlParts[1]) : 1883; // Standard-Port 1883 für MQTT</span>

<span class="fc" id="L52">        this.client = Mqtt5Client.builder() // Use Mqtt5Client instead of MqttClient</span>
<span class="fc" id="L53">                .serverHost(host)</span>
<span class="fc" id="L54">                .serverPort(port)</span>
<span class="fc" id="L55">                .identifier(clientId)</span>
<span class="fc" id="L56">                .buildAsync();</span>

<span class="fc" id="L58">        this.scheduler = Executors.newScheduledThreadPool(1);</span>

        // connect();
        // subscribeToControlTopics();
        // startPublishingElevatorStates();
<span class="fc" id="L63">    }</span>

    /**
     * Establish connection to MQTT Broker
     */
    public void connect() {
<span class="fc" id="L69">        client.connectWith()</span>
<span class="fc" id="L70">                .cleanStart(true) // MQTT5 equivalent of cleanSession</span>
<span class="fc" id="L71">                .send()</span>
<span class="fc" id="L72">                .whenComplete((connAck, throwable) -&gt; {</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">                    if (throwable != null) {</span>
<span class="nc" id="L74">                        System.err.println(&quot;Connection failed: &quot; + throwable.getMessage());</span>
                    } else {
<span class="fc" id="L76">                        System.out.println(&quot;Connected to MQTT broker: &quot; + connAck.getType());</span>
                    }
<span class="fc" id="L78">                });</span>
<span class="fc" id="L79">    }</span>

    /**
     * Reconnect to MQTT Broker
     */
    public void reconnect() {
<span class="nc bnc" id="L85" title="All 4 branches missed.">        if (client != null &amp;&amp; !client.getState().isConnected()) {</span>
<span class="nc" id="L86">            client.toAsync().connect()</span>
<span class="nc" id="L87">                    .whenComplete((connAck, throwable) -&gt; {</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">                        if (throwable != null) {</span>
<span class="nc" id="L89">                            System.err.println(&quot;Failed to reconnect to MQTT broker: &quot; + throwable.getMessage());</span>
<span class="nc" id="L90">                            scheduler.schedule(this::reconnect, TIMEOUT_DURATION, TimeUnit.SECONDS);</span>
                        } else {
<span class="nc" id="L92">                            System.out.println(&quot;Reconnected to MQTT broker.&quot;);</span>
                        }
<span class="nc" id="L94">                    });</span>
        }
<span class="nc" id="L96">    }</span>

    /**
     * Disconnect from MQTT Broker
     */
    private void disconnect() {
<span class="nc" id="L102">        client.disconnect()</span>
<span class="nc" id="L103">                .whenComplete((ack, throwable) -&gt; {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                    if (throwable != null) {</span>
<span class="nc" id="L105">                        System.err.println(&quot;Failed to disconnect: &quot; + throwable.getMessage());</span>
                    } else {
<span class="nc" id="L107">                        System.out.println(&quot;Disconnected from MQTT broker.&quot;);</span>
                    }
<span class="nc" id="L109">                });</span>
<span class="nc" id="L110">    }</span>

    /**
     * Shutdown Hook to mitigate common issues when shutting down the client
     */
    public void addShutdownHook() {
<span class="nc" id="L116">        Runtime.getRuntime().addShutdownHook(new Thread(this::disconnect));</span>
<span class="nc" id="L117">    }</span>

    /**
     * @brief Starts publishing elevator states at regular intervals.
     *
     *        This function starts a scheduled task that polls the elevator states
     *        at regular intervals and publishes the states to the MQTT broker.
     *        If there are changes in the elevator states, the new states are
     *        published.
     */
    private void startPublishingElevatorStates() {
<span class="nc" id="L128">        ElevatorSystem previousElevatorSystem = elevatorSystem;</span>
<span class="nc" id="L129">        scheduler.scheduleAtFixedRate(() -&gt; {</span>
            try {
<span class="nc" id="L131">                elevatorSystem.updateAll();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                for (int i = 0; i &lt; (elevatorSystem.getTotalElevators()); i++) {</span>
<span class="nc" id="L133">                    Elevator previousElevator = previousElevatorSystem.getElevator(i);</span>
<span class="nc" id="L134">                    Elevator elevator = elevatorSystem.getElevator(i);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                    if (elevator.getCurrentFloor() != previousElevator.getCurrentFloor()) {</span>
<span class="nc" id="L136">                        publish(&quot;elevator/&quot; + i + &quot;/currentFloor&quot;, String.valueOf(elevator.getCurrentFloor()));</span>
                    }
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    if (elevator.getTargetedFloor() != previousElevator.getTargetedFloor()) {</span>
<span class="nc" id="L139">                        publish(&quot;elevator/&quot; + i + &quot;/targetedFloor&quot;, String.valueOf(elevator.getTargetedFloor()));</span>
                    }
<span class="nc bnc" id="L141" title="All 2 branches missed.">                    if (elevator.getCurrentSpeed() != previousElevator.getCurrentSpeed()) {</span>
<span class="nc" id="L142">                        publish(&quot;elevator/&quot; + i + &quot;/speed&quot;, String.valueOf(elevator.getCurrentSpeed()));</span>
                    }
<span class="nc bnc" id="L144" title="All 2 branches missed.">                    if (elevator.getCurrentWeight() != previousElevator.getCurrentWeight()) {</span>
<span class="nc" id="L145">                        publish(&quot;elevator/&quot; + i + &quot;/weight&quot;, String.valueOf(elevator.getCurrentWeight()));</span>
                    }
<span class="nc bnc" id="L147" title="All 2 branches missed.">                    if (elevator.getElevatorDoorStatus() != previousElevator.getElevatorDoorStatus()) {</span>
<span class="nc" id="L148">                        publish(&quot;elevator/&quot; + i + &quot;/doorState&quot;, String.valueOf(elevator.getElevatorDoorStatus()));</span>
                    }
                }
<span class="nc" id="L151">            } catch (Exception e) {</span>
<span class="nc" id="L152">                throw new RuntimeException(e);</span>
<span class="nc" id="L153">            }</span>

<span class="nc" id="L155">        }, 0, pollingInterval, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L156">    }</span>

    /**
     * @brief Publishes a message to the specified MQTT topic.
     *
     *        This function publishes a message to the specified MQTT topic with the
     *        given message content.
     *        The message is set as retained to ensure that the notification is not
     *        lost.
     *
     * @param topic          The MQTT topic to publish the message to.
     * @param messageContent The content of the message to be published.
     */
    private void publish(String topic, String messageContent) {
<span class="nc" id="L170">        client.publishWith()</span>
<span class="nc" id="L171">                .topic(topic)</span>
<span class="nc" id="L172">                .payload(messageContent.getBytes(StandardCharsets.UTF_8))</span>
<span class="nc" id="L173">                .retain(true)</span>
<span class="nc" id="L174">                .send()</span>
<span class="nc" id="L175">                .whenComplete((ack, throwable) -&gt; {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                    if (throwable != null) {</span>
<span class="nc" id="L177">                        System.err.println(&quot;Publish failed: &quot; + throwable.getMessage());</span>
                    } else {
<span class="nc" id="L179">                        System.out.println(&quot;Published: &quot; + topic + &quot; -&gt; &quot; + messageContent);</span>
                    }
<span class="nc" id="L181">                });</span>
<span class="nc" id="L182">    }</span>

    /**
     * @brief Subscribes to control topics for setting targeted floors and committed
     *        directions.
     *
     *        This function subscribes to the control topics for setting targeted
     *        floors and committed directions.
     *        When a message is received on these topics, the corresponding elevator
     *        is updated with the new targeted floor or committed direction.
     */
    private void subscribeToControlTopics() {
<span class="nc" id="L194">        client.subscribeWith()</span>
<span class="nc" id="L195">                .topicFilter(&quot;elevator/+/setTargetedFloor&quot;)</span>
<span class="nc" id="L196">                .callback(publish -&gt; {</span>
<span class="nc" id="L197">                    String topic = publish.getTopic().toString();</span>
<span class="nc" id="L198">                    String payload = new String(publish.getPayloadAsBytes(), StandardCharsets.UTF_8);</span>
<span class="nc" id="L199">                    handleSetTargetedFloor(topic, payload);</span>
<span class="nc" id="L200">                })</span>
<span class="nc" id="L201">                .send();</span>

<span class="nc" id="L203">        client.subscribeWith()</span>
<span class="nc" id="L204">                .topicFilter(&quot;elevator/+/setCommittedDirection&quot;)</span>
<span class="nc" id="L205">                .callback(publish -&gt; {</span>
<span class="nc" id="L206">                    String topic = publish.getTopic().toString();</span>
<span class="nc" id="L207">                    String payload = new String(publish.getPayloadAsBytes(), StandardCharsets.UTF_8);</span>
<span class="nc" id="L208">                    handleSetCommittedDirection(topic, payload);</span>
<span class="nc" id="L209">                })</span>
<span class="nc" id="L210">                .send();</span>

<span class="nc" id="L212">        System.out.println(&quot;Subscribed to control topics.&quot;);</span>
<span class="nc" id="L213">    }</span>

    private void handleSetTargetedFloor(String topic, String payload) {
<span class="nc" id="L216">        String[] topicLevels = topic.split(&quot;/&quot;);</span>
<span class="nc" id="L217">        int elevatorNumber = Integer.parseInt(topicLevels[1]);</span>
<span class="nc" id="L218">        int targetFloor = Integer.parseInt(payload);</span>
<span class="nc" id="L219">        elevatorSystem.getElevator(elevatorNumber).setTargetedFloor(targetFloor);</span>
<span class="nc" id="L220">        System.out.println(&quot;Set elevator &quot; + elevatorNumber + &quot; target floor to &quot; + targetFloor);</span>
<span class="nc" id="L221">    }</span>

    private void handleSetCommittedDirection(String topic, String payload) {
<span class="nc" id="L224">        String[] topicLevels = topic.split(&quot;/&quot;);</span>
<span class="nc" id="L225">        int elevatorNumber = Integer.parseInt(topicLevels[1]);</span>
<span class="nc" id="L226">        int direction = Integer.parseInt(payload);</span>
<span class="nc" id="L227">        elevatorSystem.getElevator(elevatorNumber).setCommittedDirection(direction);</span>
<span class="nc" id="L228">        System.out.println(&quot;Set elevator &quot; + elevatorNumber + &quot; committed direction to &quot; + direction);</span>
<span class="nc" id="L229">    }</span>

    /**
     * Connects to broker, subscribes to all control topics,
     * publishes all retained topics and runs the update loop.
     * 
     * @throws MqttError
     */
    public void run() {
        // Überprüfen, ob der MQTT-Client verbunden ist
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (client.getState() != MqttClientState.CONNECTED) {</span>
<span class="fc" id="L240">            System.err.println(&quot;MQTT client is not connected.&quot;);</span>
<span class="fc" id="L241">            return; // Beende die Methode, wenn der MQTT-Client nicht verbunden ist</span>
        }

        // Beide Verbindungen sind in Ordnung, also publish die retained topics
<span class="fc" id="L245">        publishRetainedTopics();</span>
<span class="fc" id="L246">    }</span>

    /**
     * Publishes the retained (static) building information topics
     * 
     * @throws MqttError
     */
    public void publishRetainedTopics() {
        String payload;
        // Sicherstellen, dass der Client verbunden ist
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (client.getState() != MqttClientState.CONNECTED) {</span>
<span class="nc" id="L257">            throw new RuntimeException(&quot;MQTT client must be connected before publishing messages&quot;);</span>
        }

        try {
            // Anzahl der Aufzüge
<span class="fc" id="L262">            payload = String.valueOf(elevatorSystem.getElevatorNum());</span>
<span class="fc" id="L263">            Mqtt5Publish publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L264">                    .topic(infoTopic + &quot;numberOfElevators&quot;)</span>
<span class="fc" id="L265">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L266">                    .retain(true) // Nachricht als retained markieren</span>
<span class="fc" id="L267">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L268">                    .build();</span>
<span class="fc" id="L269">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>

            // Anzahl der Stockwerke
<span class="fc" id="L272">            payload = String.valueOf(elevatorSystem.getNumberOfFloors());</span>
<span class="fc" id="L273">            publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L274">                    .topic(infoTopic + &quot;numberOfFloors&quot;)</span>
<span class="fc" id="L275">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L276">                    .retain(true)</span>
<span class="fc" id="L277">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L278">                    .build();</span>
<span class="fc" id="L279">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>

            // Stockwerkhöhe in Fuß
<span class="fc" id="L282">            payload = String.valueOf(elevatorSystem.getFloorHeight());</span>
<span class="fc" id="L283">            publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L284">                    .topic(infoTopic + &quot;floorHeight/feet&quot;)</span>
<span class="fc" id="L285">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L286">                    .retain(true)</span>
<span class="fc" id="L287">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L288">                    .build();</span>
<span class="fc" id="L289">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>

            // Systemtakt
<span class="fc" id="L292">            payload = String.valueOf(elevatorSystem.getClockTick());</span>
<span class="fc" id="L293">            publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L294">                    .topic(infoTopic + &quot;systemClockTick&quot;)</span>
<span class="fc" id="L295">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L296">                    .retain(true)</span>
<span class="fc" id="L297">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L298">                    .build();</span>
<span class="fc" id="L299">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>

            // RMI-Verbindungsstatus
<span class="fc" id="L302">            payload = String.valueOf(true);</span>
<span class="fc" id="L303">            publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L304">                    .topic(infoTopic + &quot;rmiConnected&quot;)</span>
<span class="fc" id="L305">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L306">                    .retain(true)</span>
<span class="fc" id="L307">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L308">                    .build();</span>
<span class="fc" id="L309">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>

<span class="nc" id="L311">        } catch (Exception exc) {</span>
<span class="nc" id="L312">            throw new RuntimeException(&quot;Error while publishing retained topics: &quot; + exc.getMessage(), exc);</span>
<span class="fc" id="L313">        }</span>
<span class="fc" id="L314">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>