<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ElevatorMQTTAdapter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">elevator-simulator-team-c</a> &gt; <a href="index.source.html" class="el_package">at.wielander.elevator.MQTT</a> &gt; <span class="el_source">ElevatorMQTTAdapter.java</span></div><h1>ElevatorMQTTAdapter.java</h1><pre class="source lang-java linenums">package at.wielander.elevator.MQTT;

import at.wielander.elevator.Model.Elevator;
import at.wielander.elevator.Model.ElevatorSystem;
import sqelevator.IElevator;
import com.hivemq.client.mqtt.MqttClientState;
import com.hivemq.client.mqtt.MqttGlobalPublishFilter;
import com.hivemq.client.mqtt.datatypes.MqttQos;
import com.hivemq.client.mqtt.mqtt5.Mqtt5AsyncClient;
import com.hivemq.client.mqtt.mqtt5.Mqtt5Client;
import com.hivemq.client.mqtt.mqtt5.message.publish.Mqtt5Publish;

import java.nio.charset.StandardCharsets;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ElevatorMQTTAdapter {
    private static final String topicBase = &quot;building/&quot;;
    public static final String infoTopic = topicBase + &quot;info/&quot;;
    private static final String statusTopic = topicBase + &quot;status/&quot;;
    private static final String controlTopic = topicBase + &quot;control/&quot;;
    public static final String infoElevatorTopic = infoTopic + &quot;elevator/&quot;;
    public static final String statusElevatorTopic = statusTopic + &quot;elevator/&quot;;
    public static final String controlElevatorTopic = controlTopic + &quot;elevator/&quot;;
    public static final String statusFloorTopic = statusTopic + &quot;floor/&quot;;
    private static final int TIMEOUT_DURATION = 10;
    private Mqtt5AsyncClient client;
    private ElevatorSystem elevatorSystem;
    private final ScheduledExecutorService scheduler;
    private int pollingInterval;
    private  ElevatorSystem previousElevatorSystem;
    private IElevator elevatorAPI;


    /**
     * Custom Exception for handling MQTT Adapter errors.
     */
    public static class MQTTAdapterException extends RuntimeException {
      
    	private static final long serialVersionUID = 1L;

    	public MQTTAdapterException(String message, Throwable cause) {
<span class="fc" id="L44">            super(message, cause);</span>
<span class="fc" id="L45">        }</span>
    }
    /**
     * Returns the current state of the MQTT client.
     *
     * @return the state of the MQTT client.
     */
    public MqttClientState getClientState() {
<span class="fc" id="L53">        return client.getState();</span>
    }
    
    /**
     * Establishes connection between the MQTT Broker and the Elevator Data Model
     *
     * @param elevatorSystem Data Model for Elevator system
     * @param brokerUrl      URL for MQTT Broker
     * @param clientId       Client ID for MQTT Broker
     */
<span class="fc" id="L63">    public ElevatorMQTTAdapter(ElevatorSystem elevatorSystem, String brokerUrl, String clientId, int pollingInterval, IElevator elevatorAPI) {</span>
<span class="fc" id="L64">        this.elevatorAPI = elevatorAPI;</span>
<span class="fc" id="L65">    	this.elevatorSystem = elevatorSystem;</span>
<span class="fc" id="L66">        this.pollingInterval = pollingInterval;</span>
        
        try {
<span class="fc" id="L69">        String[] urlParts = brokerUrl.replace(&quot;tcp://&quot;, &quot;&quot;).split(&quot;:&quot;);</span>
<span class="fc" id="L70">        String host = urlParts[0];</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        int port = urlParts.length &gt; 1 ? Integer.parseInt(urlParts[1]) : 1883; // Standard-Port 1883 für MQTT</span>

<span class="fc" id="L73">        this.client = Mqtt5Client.builder() // Use Mqtt5Client instead of MqttClient</span>
<span class="fc" id="L74">                .serverHost(host)</span>
<span class="fc" id="L75">                .serverPort(port)</span>
<span class="fc" id="L76">                .identifier(clientId)</span>
<span class="fc" id="L77">                .buildAsync();</span>

<span class="fc" id="L79">        this.scheduler = Executors.newScheduledThreadPool(1);</span>
<span class="nc" id="L80">        } catch (Exception e) {</span>
<span class="nc" id="L81">            throw new MQTTAdapterException(&quot;Failed to initialize MQTT client.&quot;, e);</span>
<span class="fc" id="L82">        }</span>
<span class="fc" id="L83">    }</span>

    /**
     * Establish connection to MQTT Broker and waits until fully connected
     * @throws InterruptedException 
     */
    public void connect() throws InterruptedException {
        try {
<span class="fc" id="L91">            client.connectWith()</span>
<span class="fc" id="L92">                  .cleanStart(true)</span>
<span class="fc" id="L93">                  .send()</span>
<span class="fc" id="L94">                  .whenComplete((connAck, throwable) -&gt; {</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">                      if (throwable != null) {</span>
<span class="nc" id="L96">                          System.err.println(&quot;Connection failed: &quot; + throwable.getMessage());</span>
                      } else {
<span class="fc" id="L98">                          System.out.println(&quot;Connected to MQTT broker: &quot; + connAck.getType());</span>
                      }
<span class="fc" id="L100">                  });</span>

            // Warten, bis der Zustand CONNECTED erreicht ist
<span class="fc" id="L103">            long startTime = System.currentTimeMillis();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">            while (client.getState() != MqttClientState.CONNECTED) {</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                if (System.currentTimeMillis() - startTime &gt; 5000) { // Timeout nach 5 Sekunden</span>
<span class="nc" id="L106">                    throw new MQTTAdapterException(&quot;Timeout while waiting for MQTT client to connect&quot;, null);</span>
                }
<span class="fc" id="L108">                Thread.sleep(100);</span>
            }
<span class="nc" id="L110">        }catch (InterruptedException e) {</span>
<span class="nc" id="L111">            throw e; // Rethrow the InterruptedException</span>
<span class="nc" id="L112">        } catch (Exception e) {</span>
<span class="nc" id="L113">            throw new MQTTAdapterException(&quot;Error during MQTT client connection.&quot;, e);</span>
<span class="fc" id="L114">        }</span>
<span class="fc" id="L115">    }</span>
    
    
    private void handleConnectionError(Throwable throwable) {
<span class="nc" id="L119">        scheduler.schedule(() -&gt; {</span>
			try {
<span class="nc" id="L121">				reconnect();</span>
<span class="nc" id="L122">			} catch (InterruptedException e) {</span>
<span class="nc" id="L123">				 Thread.currentThread().interrupt();</span>
<span class="nc" id="L124">			}</span>
<span class="nc" id="L125">		}, TIMEOUT_DURATION, TimeUnit.SECONDS);</span>
<span class="nc" id="L126">    }</span>

    /**
     * Reconnect to MQTT Broker
     * @throws InterruptedException 
     */
    public void reconnect() throws InterruptedException {
<span class="pc bpc" id="L133" title="1 of 4 branches missed.">        if (client != null &amp;&amp; !client.getState().isConnected()) {</span>
            try {
<span class="fc" id="L135">                client.toAsync().connect()</span>
<span class="fc" id="L136">                      .whenComplete((connAck, throwable) -&gt; {</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">                          if (throwable != null) {</span>
<span class="nc" id="L138">                              handleConnectionError(throwable);</span>
                          } else {
<span class="fc" id="L140">                              System.out.println(&quot;Reconnected to MQTT broker.&quot;);</span>
                          }
<span class="fc" id="L142">                      });</span>

                // Warten, bis der Zustand CONNECTED erreicht ist
<span class="fc" id="L145">                long startTime = System.currentTimeMillis();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                while (client.getState() != MqttClientState.CONNECTED) {</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                    if (System.currentTimeMillis() - startTime &gt; 5000) { // Timeout nach 5 Sekunden</span>
<span class="nc" id="L148">                        throw new MQTTAdapterException(&quot;Timeout while waiting for MQTT client to reconnect&quot;, null);</span>
                    }
<span class="fc" id="L150">                    Thread.sleep(100);</span>
                }
            } 
<span class="nc" id="L153">            catch (InterruptedException e) {</span>
<span class="nc" id="L154">                throw e; // Rethrow the InterruptedException</span>
<span class="nc" id="L155">            }catch (Exception e) {</span>
<span class="nc" id="L156">                throw new MQTTAdapterException(&quot;Error during MQTT client reconnection.&quot;, e);</span>
<span class="fc" id="L157">            }</span>
        }
<span class="fc" id="L159">    }</span>

    /**
     * Disconnect from MQTT Broker
     * @throws InterruptedException 
     */
    public void disconnect() throws InterruptedException {
        try {
<span class="fc" id="L167">            client.disconnect()</span>
<span class="fc" id="L168">                  .whenComplete((ack, throwable) -&gt; {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                      if (throwable != null) {</span>
<span class="fc" id="L170">                          System.err.println(&quot;Failed to disconnect: &quot; + throwable.getMessage());</span>
                      } else {
<span class="fc" id="L172">                          System.out.println(&quot;Disconnected from MQTT broker.&quot;);</span>
                      }
<span class="fc" id="L174">                  });</span>

            // Warten, bis der Zustand nicht mehr CONNECTED ist
<span class="fc" id="L177">            long startTime = System.currentTimeMillis();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            while (client.getState() != MqttClientState.DISCONNECTED) {</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                if (System.currentTimeMillis() - startTime &gt; 5000) { // Timeout nach 5 Sekunden</span>
<span class="nc" id="L180">                    throw new MQTTAdapterException(&quot;Timeout while waiting for MQTT client to disconnect&quot;, null);</span>
                }
<span class="fc" id="L182">                Thread.sleep(100);</span>
            }
        } 
<span class="nc" id="L185">        catch (InterruptedException e) {</span>
<span class="nc" id="L186">            throw e; // Rethrow the InterruptedException</span>
<span class="nc" id="L187">        }catch (Exception e) {</span>
<span class="nc" id="L188">            throw new MQTTAdapterException(&quot;Error during MQTT client disconnection.&quot;, e);</span>
<span class="fc" id="L189">        }</span>
<span class="fc" id="L190">    }</span>
   
    /**
     * @brief Starts publishing elevator states at regular intervals.
     *
     *        This function starts a scheduled task that polls the elevator states
     *        at regular intervals and publishes the states to the MQTT broker.
     *        If there are changes in the elevator states, the new states are
     *        published.
     */
    private void startPublishingElevatorStates() {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (client.getState() != MqttClientState.CONNECTED) {</span>
<span class="nc" id="L202">            throw new RuntimeException(&quot;MQTT client must be connected before publishing messages&quot;);</span>
        }

       
<span class="fc" id="L206">        scheduler.scheduleAtFixedRate(() -&gt; {</span>
            try {
                // Updates all elevators
<span class="fc" id="L209">                elevatorSystem.updateAll();</span>
                
                // Check if previousElevatorSystem is null (first run)
<span class="fc bfc" id="L212" title="All 2 branches covered.">                boolean isFirstRun = previousElevatorSystem == null;</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">                for (int i = 0; i &lt; elevatorSystem.getTotalElevators(); i++) {</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">                    Elevator previousElevator = previousElevatorSystem != null ? previousElevatorSystem.getElevator(i) : null;</span>
<span class="fc" id="L216">                    Elevator elevator = elevatorSystem.getElevator(i);</span>

                    // First run or change in elevator state
<span class="pc bpc" id="L219" title="2 of 6 branches missed.">                    if (isFirstRun || !String.valueOf(elevator.getCurrentFloor()).equals(String.valueOf(previousElevator != null ? previousElevator.getCurrentFloor() : null))) {</span>
<span class="fc" id="L220">                        publish(&quot;elevator/&quot; + i + &quot;/currentFloor&quot;, String.valueOf(elevator.getCurrentFloor()));</span>
                    }
<span class="pc bpc" id="L222" title="2 of 6 branches missed.">                    if (isFirstRun || !String.valueOf(elevator.getCurrentSpeed()).equals(String.valueOf(previousElevator != null ? previousElevator.getCurrentSpeed() : null))) {</span>
<span class="fc" id="L223">                        publish(&quot;elevator/&quot; + i + &quot;/speed&quot;, String.valueOf(elevator.getCurrentSpeed()));</span>
                    }
<span class="pc bpc" id="L225" title="2 of 6 branches missed.">                    if (isFirstRun || !String.valueOf(elevator.getCurrentWeight()).equals(String.valueOf(previousElevator != null ? previousElevator.getCurrentWeight() : null))) {</span>
<span class="fc" id="L226">                        publish(&quot;elevator/&quot; + i + &quot;/weight&quot;, String.valueOf(elevator.getCurrentWeight()));</span>
                    }
<span class="pc bpc" id="L228" title="2 of 6 branches missed.">                    if (isFirstRun || !String.valueOf(elevator.getElevatorDoorStatus()).equals(String.valueOf(previousElevator != null ? previousElevator.getElevatorDoorStatus() : null))) {</span>
<span class="fc" id="L229">                        publish(&quot;elevator/&quot; + i + &quot;/doorState&quot;, String.valueOf(elevator.getElevatorDoorStatus()));</span>
                    }

                    // Iterate over all buttons in the elevator
<span class="fc bfc" id="L233" title="All 2 branches covered.">                    for (int j = 1; j &lt; elevator.buttons.size()-1; j++) {</span>
<span class="pc bpc" id="L234" title="2 of 6 branches missed.">                        if (isFirstRun || !String.valueOf(elevator.buttons.get(j)).equals(String.valueOf(previousElevator != null ? previousElevator.buttons.get(j) : null))) {</span>
<span class="fc" id="L235">                            publish(&quot;elevator/&quot; + i + &quot;/button/&quot; + j, String.valueOf(elevator.buttons.get(j)));</span>
                        }
                    }

                    // Iterate over all floor buttons
<span class="fc bfc" id="L240" title="All 2 branches covered.">                    for (int k = 1; k &lt; elevatorSystem.getFloorNum(); k++) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                        if (isFirstRun || </span>
<span class="pc bpc" id="L242" title="3 of 6 branches missed.">                            elevatorSystem.getFloorButtonDown(k) != (previousElevatorSystem != null &amp;&amp; previousElevatorSystem.getFloorButtonDown(k))) {</span>
<span class="fc" id="L243">                            publish(&quot;floor/&quot; + k + &quot;/buttonDown&quot;, String.valueOf(elevatorSystem.getFloorButtonDown(k)));</span>
                        }
<span class="fc bfc" id="L245" title="All 2 branches covered.">                        if (isFirstRun || </span>
<span class="pc bpc" id="L246" title="3 of 6 branches missed.">                            elevatorSystem.getFloorButtonUp(k) != (previousElevatorSystem != null &amp;&amp; previousElevatorSystem.getFloorButtonUp(k))) {</span>
<span class="fc" id="L247">                            publish(&quot;floor/&quot; + k + &quot;/buttonUp&quot;, String.valueOf(elevatorSystem.getFloorButtonUp(k)));</span>
                        }
                    }
                }

                // Update the previous state for the next comparison
<span class="fc" id="L253">                previousElevatorSystem = elevatorSystem.copy(); // Assuming copy() method is available</span>

<span class="fc" id="L255">            } catch (Exception e) {</span>
<span class="fc" id="L256">                System.out.println(&quot;Error publishing messages&quot;);</span>
<span class="fc" id="L257">                throw new RuntimeException(&quot;Error while publishing elevator states&quot;, e);</span>
<span class="fc" id="L258">            }</span>

<span class="fc" id="L260">        }, 0, pollingInterval, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L262">    }</span>

    /**
     * @brief Publishes a message to the specified MQTT topic.
     *
     *        This function publishes a message to the specified MQTT topic with the
     *        given message content.
     *        The message is set as retained to ensure that the notification is not
     *        lost.
     *
     * @param topic          The MQTT topic to publish the message to.
     * @param payload The content of the message to be published.
     */
    private void publish(String topic, String payload) {
        try {
<span class="fc" id="L277">            Mqtt5Publish publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L278">                    .topic(topic)</span>
<span class="fc" id="L279">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L280">                    .retain(false) // Nachrichten werden nicht retained</span>
<span class="fc" id="L281">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L282">                    .build();</span>

<span class="fc" id="L284">            client.publish(publishMessage).get(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L285">        } catch (InterruptedException e) {</span>
<span class="nc" id="L286">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L287">            throw new MQTTAdapterException(&quot;Publishing interrupted for topic: &quot; + topic, e);</span>
<span class="fc" id="L288">        } catch (Exception e) {</span>
<span class="fc" id="L289">            throw new MQTTAdapterException(&quot;Failed to publish message to topic: &quot; + topic, e);</span>
<span class="fc" id="L290">        }</span>
<span class="fc" id="L291">    }</span>

    /**
     * @brief Subscribes to control topics for setting targeted floors and committed
     *        directions.
     *
     *        This function subscribes to the control topics for setting targeted
     *        floors and committed directions.
     *        When a message is received on these topics, the corresponding elevator
     *        is updated with the new targeted floor or committed direction.
     */
    private void subscribeToControlTopics() {
        try {
<span class="fc bfc" id="L304" title="All 2 branches covered.">            for (int id = 0; id &lt; elevatorSystem.getTotalElevators(); id++) {</span>
                // Subscribe to the committed direction control topic
<span class="fc" id="L306">                subscribe(&quot;elevator/&quot; + id + &quot;/committedDirection&quot;);</span>

                // Subscribe to the target floor control topic
<span class="fc" id="L309">                subscribe(&quot;elevator/&quot; + id + &quot;/targetFloor&quot;);</span>

                // Subscribe to the floor services control topics
<span class="fc bfc" id="L312" title="All 2 branches covered.">                for (int num = 0; num &lt; elevatorSystem.getNumberOfFloors(); num++) {</span>
<span class="fc" id="L313">                    subscribe(&quot;elevator/&quot; + id + &quot;/floorService/&quot; + num);</span>
                }
            }
            // Set callback to handle incoming messages
<span class="fc" id="L317">            client.toAsync().publishes(MqttGlobalPublishFilter.ALL, this::handleIncomingMessage);</span>
<span class="nc" id="L318">        } catch (Exception e) {</span>
<span class="nc" id="L319">            throw new RuntimeException(&quot;Error while subscribing to control topics&quot;, e);</span>
<span class="fc" id="L320">        }</span>
<span class="fc" id="L321">    }</span>
    private void subscribe(String topic) {
        try {
<span class="fc" id="L324">            client.subscribeWith()</span>
<span class="fc" id="L325">                  .topicFilter(topic)</span>
<span class="fc" id="L326">                  .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L327">                  .send()</span>
<span class="fc" id="L328">                  .get(pollingInterval, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L329">        } catch (InterruptedException e) {</span>
<span class="nc" id="L330">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L331">            throw new MQTTAdapterException(&quot;Subscription interrupted for topic: &quot; + topic, e);</span>
<span class="nc" id="L332">        } catch (Exception e) {</span>
<span class="nc" id="L333">            throw new MQTTAdapterException(&quot;Failed to subscribe to topic: &quot; + topic, e);</span>
<span class="fc" id="L334">        }</span>
<span class="fc" id="L335">    }</span>

    private void handleIncomingMessage(Mqtt5Publish publish){
<span class="fc" id="L338">        String topic = publish.getTopic().toString();</span>
<span class="fc" id="L339">        String payload = new String(publish.getPayloadAsBytes(), StandardCharsets.UTF_8);</span>

<span class="fc" id="L341">        System.out.println(&quot;Received message on topic: &quot; + topic + &quot; with payload: &quot; + payload);</span>

        try {
<span class="fc" id="L344">            String[] parts = topic.split(&quot;/&quot;);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">            if (topic.contains(&quot;committedDirection&quot;)) {</span>
<span class="fc" id="L346">                int elevatorNumber = Integer.parseInt(parts[1]);</span>
<span class="fc" id="L347">                int committedDirection = Integer.parseInt(payload);</span>
<span class="fc" id="L348">                System.out.println(&quot;Elevator &quot; + elevatorNumber + &quot; committed direction: &quot; + committedDirection);</span>
<span class="fc" id="L349">                elevatorAPI.setCommittedDirection(elevatorNumber, committedDirection);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            } else if (topic.contains(&quot;targetFloor&quot;)) {</span>
<span class="fc" id="L351">                int elevatorNumber = Integer.parseInt(parts[1]);</span>
<span class="fc" id="L352">                int targetFloor = Integer.parseInt(payload);</span>
<span class="fc" id="L353">                System.out.println(&quot;Elevator &quot; + elevatorNumber + &quot; target floor: &quot; + targetFloor);</span>
<span class="fc" id="L354">                elevatorAPI.setTarget(elevatorNumber, targetFloor);</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">            } else if (topic.contains(&quot;floorService&quot;)) {</span>
<span class="fc" id="L356">                int elevatorNumber = Integer.parseInt(parts[1]);</span>
<span class="fc" id="L357">                int floorNumber = Integer.parseInt(parts[3]);</span>
<span class="fc" id="L358">                boolean floorService = Boolean.parseBoolean(payload);</span>
<span class="fc" id="L359">                System.out.println(&quot;Elevator &quot; + elevatorNumber + &quot; floor &quot; + floorNumber + &quot; service: &quot; + floorService);</span>
<span class="fc" id="L360">                elevatorAPI.setServicesFloors(elevatorNumber, floorNumber, floorService);</span>
            }
        } 
<span class="nc" id="L363">        catch (Exception e) {</span>
<span class="nc" id="L364">            System.err.println(&quot;Failed to process message on topic: &quot; + topic + &quot; - Error: &quot; + e.getMessage());</span>
<span class="fc" id="L365">        }</span>
<span class="fc" id="L366">    } </span>

    /**
     * Connects to broker, subscribes to all control topics,
     * publishes all retained topics and runs the update loop.
     * 
     * @throws MQTTAdapterException
     */
    public void run() {
    	try {
        // Überprüfen, ob der MQTT-Client verbunden ist
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (client.getState() != MqttClientState.CONNECTED) {</span>
<span class="nc" id="L378">            System.err.println(&quot;MQTT client is not connected.&quot;);</span>
<span class="nc" id="L379">            return; // Beende die Methode, wenn der MQTT-Client nicht verbunden ist</span>
        }
        
<span class="fc" id="L382">        subscribeToControlTopics();</span>

        // Beide Verbindungen sind in Ordnung, also publish die retained topics
<span class="fc" id="L385">        publishRetainedTopics();</span>
        
        // start the scheduler
<span class="fc" id="L388">        startPublishingElevatorStates();</span>
<span class="fc" id="L389">        System.out.println(&quot;MQTT Adapter running&quot;);</span>
<span class="nc" id="L390">    	 } catch (Exception e) {</span>
<span class="nc" id="L391">             throw new MQTTAdapterException(&quot;Error during MQTT adapter operation.&quot;, e);</span>
<span class="fc" id="L392">         }</span>
<span class="fc" id="L393">    }</span>

    /**
     * Publishes the retained (static) building information topics
     * 
     * @throws RuntimeException
     */
    public void publishRetainedTopics() {
        String payload;
        // Sicherstellen, dass der Client verbunden ist
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (client.getState() != MqttClientState.CONNECTED) {</span>
<span class="nc" id="L404">            throw new RuntimeException(&quot;MQTT client must be connected before publishing messages&quot;);</span>
        }

        try {
            // Anzahl der Aufzüge
<span class="fc" id="L409">            payload = String.valueOf(elevatorSystem.getTotalElevators());</span>
<span class="fc" id="L410">            Mqtt5Publish publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L411">                    .topic(infoTopic + &quot;numberOfElevators&quot;)</span>
<span class="fc" id="L412">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L413">                    .retain(true) // Nachricht als retained markieren</span>
<span class="fc" id="L414">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L415">                    .build();</span>
<span class="fc" id="L416">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>
            

            // Anzahl der Stockwerke
<span class="fc" id="L420">            payload = String.valueOf(elevatorSystem.getNumberOfFloors());</span>
<span class="fc" id="L421">            publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L422">                    .topic(infoTopic + &quot;numberOfFloors&quot;)</span>
<span class="fc" id="L423">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L424">                    .retain(true)</span>
<span class="fc" id="L425">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L426">                    .build();</span>
<span class="fc" id="L427">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>

            // Stockwerkhöhe in Fuß
<span class="fc" id="L430">            payload = String.valueOf(elevatorSystem.getFloorHeight());</span>
<span class="fc" id="L431">            publishMessage = Mqtt5Publish.builder()</span>
<span class="fc" id="L432">                    .topic(infoTopic + &quot;floorHeight/feet&quot;)</span>
<span class="fc" id="L433">                    .payload(payload.getBytes(StandardCharsets.UTF_8))</span>
<span class="fc" id="L434">                    .retain(true)</span>
<span class="fc" id="L435">                    .qos(MqttQos.AT_LEAST_ONCE) // QoS Level 1 (AT_LEAST_ONCE)</span>
<span class="fc" id="L436">                    .build();</span>
<span class="fc" id="L437">            client.publish(publishMessage).get(100, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L438">        } catch (InterruptedException e) {</span>
<span class="nc" id="L439">            Thread.currentThread().interrupt(); // Thread-Unterbrechung wiederherstellen</span>
<span class="nc" id="L440">            throw new RuntimeException(&quot;Thread was interrupted while publishing retained topics&quot;, e);</span>
<span class="nc" id="L441">        } catch (Exception exc) {</span>
<span class="nc" id="L442">            throw new RuntimeException(&quot;Error while publishing retained topics: &quot; + exc.getMessage(), exc);</span>
<span class="fc" id="L443">        }</span>
<span class="fc" id="L444">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>